<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîß Diagn√≥stico WebRTC Definitivo</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
            padding: 20px; 
            background: #f8f9fa; 
            max-width: 800px; 
            margin: 0 auto; 
        }
        .test-container { 
            background: white; 
            padding: 20px; 
            border-radius: 12px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
            margin: 20px 0; 
        }
        .status { 
            font-weight: bold; 
            margin: 10px 0; 
        }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .warning { color: #ffc107; }
        .info { color: #17a2b8; }
        button { 
            background: #007bff; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            border-radius: 6px; 
            cursor: pointer; 
            margin: 5px; 
        }
        button:hover { background: #0056b3; }
        #log { 
            background: #f8f9fa; 
            border: 1px solid #e9ecef; 
            padding: 15px; 
            border-radius: 6px; 
            font-family: monospace; 
            font-size: 12px; 
            max-height: 400px; 
            overflow-y: auto; 
            white-space: pre-wrap; 
        }
        .step { 
            border-left: 3px solid #007bff; 
            padding-left: 15px; 
            margin: 15px 0; 
        }
        video {
            width: 100%;
            max-width: 400px;
            height: 300px;
            background: #000;
            border-radius: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>üîß Diagn√≥stico WebRTC Definitivo</h1>
    <p>Testando especificamente o problema de conex√£o WebRTC com LiveKit.</p>

    <div class="test-container">
        <h2>üéØ Teste Focado na Conex√£o</h2>
        <button onclick="testarConexaoFocada()">üöÄ Testar Agora</button>
        <button onclick="limparLog()">üßπ Limpar Log</button>
        <div id="status-geral" class="status">Aguardando teste...</div>
        <div id="log"></div>
    </div>

    <div class="test-container">
        <h2>üìπ V√≠deo Local</h2>
        <button onclick="testarVideoLocal()">üì∑ Testar C√¢mera</button>
        <div id="video-container">
            <video id="localVideo" autoplay muted playsinline></video>
        </div>
    </div>

    <script>
        const log = document.getElementById('log');
        const statusGeral = document.getElementById('status-geral');

        function addLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const typeIcon = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            log.textContent += `[${timestamp}] ${typeIcon} ${message}\n`;
            log.scrollTop = log.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function limparLog() {
            log.textContent = '';
            statusGeral.textContent = 'Log limpo. Pronto para novo teste.';
            statusGeral.className = 'status info';
        }

        async function testarVideoLocal() {
            try {
                addLog('Testando acesso √† c√¢mera local...');
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                
                const video = document.getElementById('localVideo');
                video.srcObject = stream;
                addLog('‚úÖ C√¢mera local funcionando!', 'success');
                
                // Parar stream ap√≥s 10 segundos
                setTimeout(() => {
                    stream.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                    addLog('C√¢mera local parada.', 'info');
                }, 10000);
                
            } catch (error) {
                addLog(`‚ùå Erro na c√¢mera: ${error.message}`, 'error');
            }
        }

        async function testarConexaoFocada() {
            statusGeral.textContent = 'Executando teste focado...';
            statusGeral.className = 'status warning';
            
            addLog('üöÄ Iniciando teste focado de WebRTC...');
            
            try {
                // Passo 1: Carregar SDK
                addLog('Passo 1: Verificando LiveKit SDK...');
                if (typeof LivekitClient === 'undefined') {
                    addLog('‚ùå LiveKit SDK n√£o carregado', 'error');
                    return;
                }
                addLog('‚úÖ LiveKit SDK carregado', 'success');

                // Passo 2: Configura√ß√µes WebRTC espec√≠ficas
                addLog('Passo 2: Configurando WebRTC para localhost...');
                const roomOptions = {
                    publishDefaults: {
                        videoSimulcastLayers: [{ quality: 'low' }]
                    },
                    adaptiveStream: false,
                    dynacast: false,
                    // CONFIGURA√á√ÉO CR√çTICA: ICE servers para localhost
                    rtcConfig: {
                        iceServers: [
                            // SEM servidores STUN externos - apenas localhost
                        ],
                        iceTransportPolicy: 'all',
                        bundlePolicy: 'max-bundle',
                        iceCandidatePoolSize: 0
                    }
                };

                const room = new LivekitClient.Room(roomOptions);
                addLog('‚úÖ Room criada com configura√ß√£o localhost', 'success');

                // Passo 3: Event listeners detalhados
                room.on('connected', () => {
                    addLog('üéâ SUCESSO: Conectado ao LiveKit!', 'success');
                    statusGeral.textContent = '‚úÖ Conex√£o bem-sucedida!';
                    statusGeral.className = 'status success';
                });

                room.on('disconnected', (reason) => {
                    addLog(`‚ùå Desconectado: ${reason}`, 'error');
                });

                room.on('connectionStateChanged', (state) => {
                    addLog(`üîÑ Estado da conex√£o: ${state}`, 'info');
                });

                room.on('participantConnected', (participant) => {
                    addLog(`üë§ Participante conectado: ${participant.identity}`, 'success');
                });

                room.on('trackSubscribed', (track, publication, participant) => {
                    addLog(`üìπ Track recebido: ${track.kind} de ${participant.identity}`, 'success');
                });

                // Passo 4: Solicitar token
                addLog('Passo 3: Solicitando token JWT...');
                const tokenResponse = await fetch('/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        room: 'teste-webrtc',
                        identity: 'debug-user-' + Date.now()
                    })
                });

                if (!tokenResponse.ok) {
                    throw new Error(`Erro no token: ${tokenResponse.status}`);
                }

                const tokenData = await tokenResponse.json();
                addLog('‚úÖ Token JWT recebido', 'success');

                // Passo 5: Conectar com timeout
                addLog('Passo 4: Conectando ao LiveKit (timeout 30s)...');
                
                const connectPromise = room.connect('ws://localhost:7880', tokenData.token);
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Timeout de 30s')), 30000)
                );

                await Promise.race([connectPromise, timeoutPromise]);

            } catch (error) {
                addLog(`‚ùå ERRO: ${error.message}`, 'error');
                statusGeral.textContent = `‚ùå Falha: ${error.message}`;
                statusGeral.className = 'status error';
                
                // Diagn√≥stico adicional
                if (error.message.includes('pc connection')) {
                    addLog('üîç DIAGN√ìSTICO: Problema WebRTC detectado', 'warning');
                    addLog('üí° SOLU√á√ÉO: Verificar configura√ß√£o de rede Docker', 'warning');
                }
            }
        }
    </script>

    <!-- LiveKit SDK com fallback -->
    <script src="https://cdn.jsdelivr.net/npm/livekit-client@2.7.0/dist/livekit-client.umd.min.js"></script>
    <script>
        if (typeof LivekitClient === 'undefined') {
            console.log('Fallback: Carregando LiveKit SDK do unpkg...');
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/livekit-client@2.7.0/dist/livekit-client.umd.min.js';
            document.head.appendChild(script);
        }
    </script>
</body>
</html>
